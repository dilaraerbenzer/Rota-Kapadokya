# -*- coding: utf-8 -*-
"""prediction_ml.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T1u_a-91PceK9Nxigt1g-9E2cxj1Q86l
"""

import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import OneHotEncoder
from sklearn.metrics import accuracy_score, classification_report

import json

import os
from google.colab import files

!pip install pyngrok==4.1.10 --quiet
!ngrok authtoken 2wGzL7wRCHt0p43juiWdx6yDqup_7JgggGvgDxLp4Qsp2d3W5 # authenticate with ngrok
from pyngrok import ngrok

public_url = ngrok.connect(8888, bind_tls=True, url='poorly-enough-wren.ngrok-free.app').public_url
print(f"Public URL: {public_url}")

from flask import Flask, request, jsonify
!pip install flask-cors==3.0.10
from flask_cors import CORS, cross_origin

app = Flask(_name_)
CORS(app)

@app.route('/predict', methods=['POST', 'OPTIONS'])
@cross_origin()
def predict():
    if request.method == 'OPTIONS':
        response = jsonify({})  # empty response for preflight
        response.headers.add('Access-Control-Allow-Origin', '*')
        response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')
        response.headers.add('Access-Control-Allow-Methods', 'POST')
        return response

    data = request.get_json()

    customers_df = pd.read_csv('customers.csv',
                              encoding='latin1',
                              names=['name', 'surname', 'nationality', 'city', 'age_gender', 'group', 'arrival_date', 'departure_date', 'service'],
                              quotechar='"',
                              skipinitialspace=True)

    #data = json.loads(data)
    #5 customers_df = pd.DataFrame(data["old"])

    customers_df[['age', 'gender']] = customers_df['age_gender'].str.extract(r'(\d+)([MF])')
    customers_df['age'] = customers_df['age'].astype(int)  # Convert age to integer

    X = customers_df[['nationality', 'city', 'age', 'gender']]  # features
    y = customers_df['service']  # target

    # OneHotEncoder for categorical variables
    encoder = OneHotEncoder(handle_unknown='ignore', sparse_output=False)

    # transform the categorical data into one-hot encoded columns
    X_encoded = encoder.fit_transform(X[['nationality', 'city', 'gender']])

    # convert the encoded columns back into a DataFrame and add the age
    X_encoded_df = pd.DataFrame(X_encoded, columns=encoder.get_feature_names_out(['nationality', 'city', 'gender']))
    X_final = pd.concat([X[['age']], X_encoded_df], axis=1)

    # random forest model
    model = RandomForestClassifier()
    model.fit(X_final, y)

    # predictions on the training set
    y_pred = model.predict(X_final)

    # accuracy and classification report
    print("Accuracy:", accuracy_score(y, y_pred))
    print("\nClassification Report:\n", classification_report(y, y_pred))

    # test customer data
    new_customer = pd.DataFrame({
        #5 'age': [data["newData"]["age"]],
        'age' : [19],
    })

    # applying OneHotEncoder for the unseen dat
    #5 new_customer_encoded = encoder.transform([[data["newData"]["nationality"],data["newData"]["city"],data["newData"]["gender"]]])
    new_customer_encoded = encoder.transform([["dehset","purna","F"]])

    # converting encoded columns back into a DataFrame
    new_customer_encoded_df = pd.DataFrame(new_customer_encoded, columns=encoder.get_feature_names_out(['nationality', 'city', 'gender']))

    new_customer_final = pd.concat([new_customer, new_customer_encoded_df], axis=1)

    # prediction probabilities for the new customer
    prediction_probabilities = model.predict_proba(new_customer_final)

    # dictionary with the class labels and their respective probabilities
    probability_dict = dict(zip(model.classes_, prediction_probabilities[0]))

    # print predicted service and the probabilities for each service
    print("\nPredicted Service for New Customer:", model.classes_[prediction_probabilities.argmax()])
    print("\nCompatibility with Services (in percentage):")
    for service, probability in probability_dict.items():
        print(f"{service}: {probability * 100:.2f}%")

    response = jsonify(model.classes_[prediction_probabilities.argmax()])
    # response.headers.add('Access-Control-Allow-Origin', '*')
    # response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')
    # response.headers.add('Access-Control-Allow-Methods', 'POST')
    return response

if _name_ == '_main_':
    app.run(host='0.0.0.0', port=8888)  # Run on all interfaces